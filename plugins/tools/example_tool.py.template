"""Example tool plugin template.

Copy this file to create your own custom tool:
1. Rename the file (e.g., my_tool.py)
2. Update the class name and attributes
3. Implement your tool logic in _run()
4. Save and restart the runtime - your tool will be discovered!
"""

from langchain_core.tools import BaseTool
from pydantic import BaseModel, Field
from typing import Optional


class ExampleToolInput(BaseModel):
    """Input schema for the example tool.
    
    Define the parameters your tool accepts using Pydantic fields.
    """
    query: str = Field(..., description="The input query to process")
    option: Optional[str] = Field("default", description="Optional parameter with default")
    max_length: int = Field(100, description="Maximum length of response")


class ExampleCustomTool(BaseTool):
    """Example custom tool template.
    
    This tool demonstrates the minimum requirements for a plugin tool.
    Replace this with your own implementation.
    """
    
    # REQUIRED: Unique tool name (snake_case recommended)
    name: str = "example_custom_tool"
    
    # REQUIRED: Description of what the tool does
    description: str = (
        "Example tool that demonstrates the plugin system. "
        "Replace this with a description of your tool's functionality."
    )
    
    # OPTIONAL: Input schema (recommended for validation)
    args_schema: type[BaseModel] = ExampleToolInput
    
    # OPTIONAL: Plugin version
    __version__ = "1.0.0"
    
    def _run(self, query: str, option: str = "default", max_length: int = 100) -> str:
        """Execute the tool (synchronous version).
        
        This method must be implemented. It receives the parameters defined
        in your args_schema and should return a string result.
        
        Args:
            query: The input query
            option: Optional parameter
            max_length: Maximum response length
            
        Returns:
            Tool execution result as string
        """
        # Implement your tool logic here
        result = f"Processed '{query}' with option='{option}' (max_length={max_length})"
        
        # Truncate if needed
        if len(result) > max_length:
            result = result[:max_length-3] + "..."
        
        return result
    
    async def _arun(self, query: str, option: str = "default", max_length: int = 100) -> str:
        """Execute the tool (asynchronous version).
        
        This method is optional but recommended for async operations.
        If not implemented, LangChain will run _run() in a thread.
        
        Args:
            query: The input query
            option: Optional parameter
            max_length: Maximum response length
            
        Returns:
            Tool execution result as string
        """
        # For async operations (API calls, I/O, etc.), implement here
        # For simple tools, you can just call the sync version:
        return self._run(query, option, max_length)


class SimpleExampleTool(BaseTool):
    """Simpler example without input schema.
    
    You can create tools without explicit input schemas for simple cases.
    """
    
    name: str = "simple_example_tool"
    description: str = "A simple tool with no input schema"
    
    def _run(self, text: str) -> str:
        """Simple execution with a single string parameter."""
        return f"Processed: {text.upper()}"


class AdvancedExampleTool(BaseTool):
    """Example showing more advanced features."""
    
    name: str = "advanced_example_tool"
    description: str = "Advanced tool with error handling and logging"
    
    def _run(self, operation: str, value: int) -> str:
        """Tool with error handling and validation."""
        import logging
        logger = logging.getLogger(__name__)
        
        try:
            # Validate inputs
            if operation not in ["increment", "decrement", "double"]:
                return f"Error: Unknown operation '{operation}'"
            
            # Perform operation
            if operation == "increment":
                result = value + 1
            elif operation == "decrement":
                result = value - 1
            else:  # double
                result = value * 2
            
            logger.debug(f"Executed {operation} on {value}, result: {result}")
            return f"Result: {result}"
            
        except Exception as e:
            logger.error(f"Tool execution failed: {e}")
            return f"Error: {str(e)}"


# You can define multiple tools in one file - all will be discovered!
